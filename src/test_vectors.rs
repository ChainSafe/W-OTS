#[cfg(test)]
mod tests {
    use crate::hasher::{Blake2bHasher, Hasher, Sha3_224Hasher, Sha3_256Hasher};
    use crate::keys::Key;
    use crate::params::{checksum, Params, SEED_SIZE};
    use crate::security;
    use crate::security::ParamsEncoding;

    use hex;

    const TEST_DATA: &[u8; 10] = b"XX NETWORK";

    const TEST_VECTOR_256: [u8; 34] = [
        38, 127, 249, 206, 220, 112, 171, 226, 191, 50, 63, 220, 72, 3, 189, 209, 251, 182, 0, 86,
        98, 113, 43, 174, 7, 95, 115, 145, 216, 128, 64, 1, 16, 0,
    ];

    const CHECKSUM_256: [u8; 2] = [16, 0];

    const TEST_VECTOR_224: [u8; 30] = [
        82, 8, 4, 8, 108, 101, 58, 230, 192, 187, 159, 234, 252, 38, 125, 184, 97, 60, 179, 51,
        224, 146, 175, 237, 207, 0, 109, 245, 13, 112,
    ];

    const CHECKSUM_224: [u8; 2] = [13, 112];

    const TEST_VECTOR_192: [u8; 26] = [
        82, 8, 4, 8, 108, 101, 58, 230, 192, 187, 159, 234, 252, 38, 125, 184, 97, 60, 179, 51,
        224, 146, 175, 237, 11, 165,
    ];

    const CHECKSUM_192: [u8; 2] = [11, 165];

    #[test]
    fn checksum_256_test() {
        let mut hasher = Sha3_256Hasher::new();
        hasher.write(TEST_DATA.to_vec());
        let mut out = vec![0u8; Sha3_256Hasher::size()];
        hasher.sum(&mut out);

        let ret = checksum(&out);
        assert_eq!(ret, CHECKSUM_256);
    }

    #[test]
    fn checksum_224_test() {
        let mut hasher = Sha3_224Hasher::new();
        hasher.write(TEST_DATA.to_vec());
        let mut out = vec![0u8; Sha3_224Hasher::size()];
        hasher.sum(&mut out);

        let ret = checksum(&out);
        assert_eq!(ret, CHECKSUM_224);
    }

    #[test]
    fn checksum_192_test() {
        let mut hasher = Sha3_224Hasher::new();
        hasher.write(TEST_DATA.to_vec());
        let mut out = vec![0u8; Sha3_224Hasher::size()];
        hasher.sum(&mut out);

        let ret = checksum(&out[..24]);
        assert_eq!(ret, CHECKSUM_192);
    }

    #[test]
    fn max_checksum_256_test() {}

    #[test]
    fn min_checksum_test() {}

    #[test]
    fn key_sign_consistency_test() {
        for i in 0..5 {
            let encoding = ParamsEncoding::from(i as u8);
            match encoding {
                ParamsEncoding::Level0 => {
                    consistency_params_test::<Blake2bHasher, Sha3_224Hasher>(
                        security::level_0_params(),
                    );
                }
                ParamsEncoding::Level1 => {
                    consistency_params_test::<Blake2bHasher, Sha3_224Hasher>(
                        security::level_1_params(),
                    );
                }
                ParamsEncoding::Level2 => {
                    consistency_params_test::<Blake2bHasher, Sha3_224Hasher>(
                        security::level_2_params(),
                    );
                }
                ParamsEncoding::Level3 => {
                    consistency_params_test::<Blake2bHasher, Sha3_224Hasher>(
                        security::level_3_params(),
                    );
                }
                ParamsEncoding::Consensus => {
                    consistency_params_test::<Blake2bHasher, Sha3_256Hasher>(
                        security::consensus_params(),
                    );
                }
                _ => {
                    assert!(false);
                }
            };
        }
    }

    fn consistency_params_test<PRFH: Hasher + Clone, MSGH: Hasher + Clone>(
        params: Params<PRFH, MSGH>,
    ) {
        let params_copy = params.clone();
        println!("testing encoding {:?}", params.encoding);
        let mut key = Key::new(params_copy).unwrap();
        key.generate().unwrap();
        let signature = key.sign(TEST_DATA).unwrap();
        assert_eq!(signature[0], u8::from(&params.encoding));
        assert_eq!(signature[1..1 + SEED_SIZE], key.p_seed);

        let compare = match params.m {
            32 => TEST_VECTOR_256.to_vec(),
            28 => TEST_VECTOR_224.to_vec(),
            24 => TEST_VECTOR_192.to_vec(),
            _ => {
                assert!(false);
                return;
            }
        };

        let offset = 1 + SEED_SIZE;
        let chains = &key.chains.unwrap();
        for i in 0..params.total {
            let start = i * params.n;
            let end = (i + 1) * params.n;
            assert_eq!(
                signature[offset + start..offset + end],
                chains[compare[i] as usize][start..end]
            );
        }

        params
            .verify(TEST_DATA, &signature[1..], &key.public_key)
            .unwrap();
    }

    #[test]
    fn verify_conformance_test() {
        // verify a signature generated by the Go implementation
        let msg = hex::decode("e36756d3590e9277ad44802df50a8ded1fec2a4cc622c7cd0114e6a3b0ce28b08f715e36b197fafb7d63834c4b89d309cb40bad0e85125a5385a6974b2c8190433679d7f601fae6eee2b02f51540e37c5f37dd1f1bf00a986e506b781a08fc2ec9786957d27f2af2c4e649d0cd455b394a8d34995db4fe3395ff7870f037276785f29c7b927ab8374c3144209fed7666acb885300c872057970141bbfb9175fb900755a057ecdee8a97089f330d1982df21cce90cbf878eab26902869f7aa3e1d6ec4a25ab932f74119c53239067231cbd75a86f73f59c61bc95e1f665fd006692df51e60829f70730685455a2c02e0d34a2ee9af65ad39e8c83553f5cce");
        let public_key =
            hex::decode("82877d8b2af93409789291f85cd5ce039b8a69e6d69ed4c573fb06f851bca298");
        let signature = hex::decode("04a2d5e4cc35893506e5dfc6e219f0dd7be41edebc64340073060fa3be2ccd7031c2c5cccecfe87794c8351d1f75855fb2718fa6c7173e77d382211db2b209933cf6f1346d1d321887945277741d7e9b3e0db33dafce52c0aed95c5b928aefa2d7aaf4303aed9357e7dba7701440437c2f27720a2a6b2975558c36972fd8fcabe6b6bbb57261a2e377ee95ac94f6723a8bad7287c9993bef31086b9496c7305581bf204ffd293935c0d54a12bfa66b0d81e4e790e24a10987e32020e92fb77540049445c2b79c8413f61f61227053704c6e9b80c983fb59ca4bd4268f1e9262167d0ac5f1bdabb83cc6d5768acc0312354033a24b6b8c5328d8ed14128bff8329ff3f14c50a021d276bac97d1681cd65cb67d57132f2fdd8008fcc6d9b47523a02517d9c53b75ed957e7ea6ef0bfcdc11db5bc40cae92fd465de01e2d782f96ba9f7bc242d89e0dbbc15910c31ad8142a7ea89fb18fd7e1e7b4c177d6d9a56b4c7368e0a86ff91bc7c2f7ce08c19a8f9f4bf2839a67ab50d3d9ba84cd004aef0247209e07c772d9d5009640a2e20047b3d53a6d3a824bc797119e2a54d0f8db066823dc84cc410b9fabb8ce5007c41f255fe078e3863b13255b79a7e67646a910f9af027885691c5fc10cd1b356931e04ae73e90d9c3176136d5df6359ae28e9d6c3a809766b7fad498befcb0c9d6a0b03de4aadd8e23912d31d91a4a506d5a4985022b095a7ab632cbc196e0453e2ab3d4271ea4198be1ca087910c2a0284426202f654920da11ab27ac264108794bf338ba5af725df957673e04eb88ba393a0fd1b5af09ad79fb85ea8aabc5a6c94de55ba794f328e726e80d7f8cb308f736e1a4ff547aab3be19152e4cca3f87fb0651b07aaf40b29573f19478a8a5821a8f8a52f1959d58731b223d16e5438f861f040c5d2ec78c48f099f0ec90e530757d1c1af407037451b53f84e86d110097ea48a2bca79c009c60135524382c44bbecb75aa98519d7c07fbd36bea18ef27793b47c44e46b994b1cd0564298bfed72e3d7b7ce0eb6c5e6825d52aebd17386f6dc36fe9b37b16eb14c6774bd9f0857a202ce34faa834a7f06c2455aea8e48d3b0993fa8e1a1a03db09adea74feff377ac377592ee153eb21eadf5fbdf833fd9812acab05393e7107803920647b4596f7278b4a874f236623173d9e18cc58a2ea7438bdc9cdb792f8b5466a1a9b556f0fcbc739b0dd1b5fb0bba2ce71e9d5c793d14a7a1614d2106fd7a017305be43cc2898e2ecd028cbfcee626fe4c971bb8d11198996b4121a4ba16a8cffcec562bf9561d93d4243aae4ae1b6774063bcb24d1791e56d59f32d1f9810ba040c78846316c3207928c34b90118942d92ceae044776c99e01da9036c88533f890deab9df6bc43850928c5039d7cc0a530514ca98e8521dd5bd4be1ca526062a7d8c6270f81bb93d1723b13ff60effac22b8b0f61ebf2759ba30d02b9da88eb11d66f3070172c7b9148411e69c505eb8565c76b4f555ab891b38ed0910e68dd245322570720eff94ca8039857e2ad136bd0f3e141585ce8017b6ad9119390e996a908674f23");
        security::verify(&msg.unwrap(), &signature.unwrap(), &public_key.unwrap()).unwrap();
    }

    #[test]
    fn compute_public_key_conformance_test() {
        let secret_seed =
            hex::decode("66d24fb8688c9a0024c56925e2ce2af01ecabdb5a1097dae43d91f1d4ae87afc")
                .unwrap();
        let public_seed =
            hex::decode("8cd018d6da1d57511fc18ad0ec914346d5f40d2eaf45dc8471b9799f413f3064")
                .unwrap();
        let expected_secret_key = hex::decode("dde323e7cb7ff3087c346615c098441ccf102f72beade7f987edbd3352c3a4eb022f35de76b8363436cf71e05f33bd3dfc7a2fc260e757f81c233d4e615b919b0b1801738312fabc746b0ce5d0d324f0829ea8656a84165391f79df9637ec7ec9ab7c49e1d220ee26978eb96b1317ee35c9597ad89ca4a360aec61e84add353d5c5e1fce06525197be5d070ac78e3a481392a84ad67dcac3a8337ca12cc72b69571311af75c66486bd8e9f436b888f2880dbe751d05371031bbab6fcc9812fb4a40379b397879a9f804f61d957e51e7b166d2798ea8c60e8e6d6749f7681e2e56695f49eccc946d2d3d95219f8eeef6a9be09a5b1d0a74323bc5b9a59e57a2d83de0cbe4b41e1322c64786809232eefee2bd97efa8773977e61b68871569b625a28ad7281d24c9a1bd5464e62656099dcea8bdac2f4bdac6cb721164ccadd327c115c7eb87ccb835d37d287aaa41e53d37d789abdeedae99025b7943cf5f93c91b4ba8daa27756f69a2d50336377a96c42d18e4bc2357d835c346b1f8071974b61ceab7183f8cd765e0be54ebb8f20443c7e682e259c457dc7c38595399421da1277f376d68d112d6f71d1876f4dcd194c5e8b51748d141492ed1d79fef771dd258de4036d8d4f021d884dfd1386d79823ad7943cc906090df72e996f0f74b2baef9c9edfa0cce9f5b68ab68684095d9f66f3ae0b32678bf43b3519a02b1a4bb05026d4095c53554").unwrap();
        let expected_public_key =
            hex::decode("7bd49cdc5f70766c70c973a2d6c76b964333ac853c5ae8ecbfef5f1fde08705a")
                .unwrap();
        let mut seed = [0u8; 32];
        seed.copy_from_slice(&secret_seed);
        let mut p_seed = [0u8; 32];
        p_seed.copy_from_slice(&public_seed);
        let key = Key::from_seed(security::level_0_params(), seed, p_seed).unwrap();
        assert_eq!(key.secret_key, expected_secret_key);
        assert_eq!(key.public_key, expected_public_key);
    }
}
